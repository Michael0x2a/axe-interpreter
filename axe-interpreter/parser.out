Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    ABOUT
    DEREFERENCE
    HELP
    GETKEY
    OPEN
    RECT
    LINE
    PXL_TEST
    DRAW
    STRING
    VERTICAL
    DISPGRAPH
    HORIZONTAL
    ELSE
    CLRDRAW
    STATE
    RECTI
    PAUSE
    RETURN
    ELSEIF
    PXL_CHANGE
    PXL_OFF

Grammar

Rule 0     S' -> program
Rule 1     block -> block block
Rule 2     block -> newline block
Rule 3     block -> line
Rule 4     block -> control
Rule 5     newline -> COLON
Rule 6     newline -> NEWLINE
Rule 7     operator -> ADD
Rule 8     operator -> SUB
Rule 9     operator -> MUL
Rule 10    operator -> DIV
Rule 11    operator -> MOD
Rule 12    operator -> LT
Rule 13    operator -> LE
Rule 14    operator -> EQ
Rule 15    operator -> NE
Rule 16    operator -> GT
Rule 17    operator -> GE
Rule 18    newline -> newline newline
Rule 19    control -> IF expression newline block END newline
Rule 20    control -> REPEAT expression newline block END newline
Rule 21    control -> WHILE expression newline block END newline
Rule 22    expression -> expression ASSIGN pointer
Rule 23    expression -> pointer DECREMENT
Rule 24    expression -> pointer INCREMENT
Rule 25    factor -> SUB expression
Rule 26    expression -> LPAREN expression RPAREN
Rule 27    expression -> NUMBER
Rule 28    expression -> tempexpression
Rule 29    factor -> LPAREN factor RPAREN
Rule 30    factor -> expression
Rule 31    factor -> tempexpression
Rule 32    factor -> NUMBER
Rule 33    line -> ID
Rule 34    line -> DISP expression newline
Rule 35    line -> expression newline
Rule 36    line -> factor newline
Rule 37    line -> meta
Rule 38    meta -> DEBUG expression newline
Rule 39    meta -> EXIT newline
Rule 40    control -> FOR LPAREN expression RPAREN newline block END newline
Rule 41    control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
Rule 42    expression -> expression operator factor
Rule 43    pointer -> VAR
Rule 44    pointer -> LBRACK expression RBRACK RMODIFIER
Rule 45    pointer -> LBRACK expression RBRACK
Rule 46    program -> program block
Rule 47    program -> block
Rule 48    tempexpression -> CONST
Rule 49    tempexpression -> pointer
Rule 50    tempexpression -> RAND
Rule 51    line -> PXL_ON LPAREN expression COMMA expression RPAREN

Terminals, with rules where they appear

ABOUT                : 
ADD                  : 7
ASSIGN               : 22
CLRDRAW              : 
COLON                : 5
COMMA                : 41 41 51
CONST                : 48
DEBUG                : 38
DECREMENT            : 23
DEREFERENCE          : 
DISP                 : 34
DISPGRAPH            : 
DIV                  : 10
DRAW                 : 
ELSE                 : 
ELSEIF               : 
END                  : 19 20 21 40 41
EQ                   : 14
EXIT                 : 39
FOR                  : 40 41
GE                   : 17
GETKEY               : 
GT                   : 16
HELP                 : 
HORIZONTAL           : 
ID                   : 33
IF                   : 19
INCREMENT            : 24
LBRACK               : 44 45
LE                   : 13
LINE                 : 
LPAREN               : 26 29 40 41 51
LT                   : 12
MOD                  : 11
MUL                  : 9
NE                   : 15
NEWLINE              : 6
NUMBER               : 27 32
OPEN                 : 
PAUSE                : 
PXL_CHANGE           : 
PXL_OFF              : 
PXL_ON               : 51
PXL_TEST             : 
RAND                 : 50
RBRACK               : 44 45
RECT                 : 
RECTI                : 
REPEAT               : 20
RETURN               : 
RMODIFIER            : 44
RPAREN               : 26 29 40 41 51
STATE                : 
STRING               : 
SUB                  : 8 25
VAR                  : 43
VERTICAL             : 
WHILE                : 21
error                : 

Nonterminals, with rules where they appear

block                : 1 1 2 19 20 21 40 41 46 47
control              : 4
expression           : 19 20 21 22 25 26 30 34 35 38 40 41 41 42 44 45 51 51
factor               : 29 36 42
line                 : 3
meta                 : 37
newline              : 2 18 18 19 19 20 20 21 21 34 35 36 38 39 40 40 41 41
operator             : 42
pointer              : 22 23 24 41 49
program              : 46 0
tempexpression       : 28 31

Parsing method: LALR

state 0

    (0) S' -> . program
    (46) program -> . program block
    (47) program -> . block
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 18
    program                        shift and go to state 13
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 28

state 1

    (4) block -> control .

    COLON           reduce using rule 4 (block -> control .)
    NEWLINE         reduce using rule 4 (block -> control .)
    ID              reduce using rule 4 (block -> control .)
    DISP            reduce using rule 4 (block -> control .)
    PXL_ON          reduce using rule 4 (block -> control .)
    IF              reduce using rule 4 (block -> control .)
    REPEAT          reduce using rule 4 (block -> control .)
    WHILE           reduce using rule 4 (block -> control .)
    FOR             reduce using rule 4 (block -> control .)
    LPAREN          reduce using rule 4 (block -> control .)
    NUMBER          reduce using rule 4 (block -> control .)
    SUB             reduce using rule 4 (block -> control .)
    DEBUG           reduce using rule 4 (block -> control .)
    EXIT            reduce using rule 4 (block -> control .)
    VAR             reduce using rule 4 (block -> control .)
    LBRACK          reduce using rule 4 (block -> control .)
    CONST           reduce using rule 4 (block -> control .)
    RAND            reduce using rule 4 (block -> control .)
    END             reduce using rule 4 (block -> control .)
    $end            reduce using rule 4 (block -> control .)


state 2

    (34) line -> DISP . expression newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    LPAREN          shift and go to state 30
    NUMBER          shift and go to state 32
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    tempexpression                 shift and go to state 29
    expression                     shift and go to state 31
    pointer                        shift and go to state 11

state 3

    (48) tempexpression -> CONST .

    ASSIGN          reduce using rule 48 (tempexpression -> CONST .)
    COLON           reduce using rule 48 (tempexpression -> CONST .)
    NEWLINE         reduce using rule 48 (tempexpression -> CONST .)
    ADD             reduce using rule 48 (tempexpression -> CONST .)
    SUB             reduce using rule 48 (tempexpression -> CONST .)
    MUL             reduce using rule 48 (tempexpression -> CONST .)
    DIV             reduce using rule 48 (tempexpression -> CONST .)
    MOD             reduce using rule 48 (tempexpression -> CONST .)
    LT              reduce using rule 48 (tempexpression -> CONST .)
    LE              reduce using rule 48 (tempexpression -> CONST .)
    EQ              reduce using rule 48 (tempexpression -> CONST .)
    NE              reduce using rule 48 (tempexpression -> CONST .)
    GT              reduce using rule 48 (tempexpression -> CONST .)
    GE              reduce using rule 48 (tempexpression -> CONST .)
    RPAREN          reduce using rule 48 (tempexpression -> CONST .)
    COMMA           reduce using rule 48 (tempexpression -> CONST .)
    RBRACK          reduce using rule 48 (tempexpression -> CONST .)


state 4

    (25) factor -> SUB . expression
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    LPAREN          shift and go to state 30
    NUMBER          shift and go to state 32
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    pointer                        shift and go to state 11
    tempexpression                 shift and go to state 29
    expression                     shift and go to state 33

state 5

    (50) tempexpression -> RAND .

    ASSIGN          reduce using rule 50 (tempexpression -> RAND .)
    COLON           reduce using rule 50 (tempexpression -> RAND .)
    NEWLINE         reduce using rule 50 (tempexpression -> RAND .)
    ADD             reduce using rule 50 (tempexpression -> RAND .)
    SUB             reduce using rule 50 (tempexpression -> RAND .)
    MUL             reduce using rule 50 (tempexpression -> RAND .)
    DIV             reduce using rule 50 (tempexpression -> RAND .)
    MOD             reduce using rule 50 (tempexpression -> RAND .)
    LT              reduce using rule 50 (tempexpression -> RAND .)
    LE              reduce using rule 50 (tempexpression -> RAND .)
    EQ              reduce using rule 50 (tempexpression -> RAND .)
    NE              reduce using rule 50 (tempexpression -> RAND .)
    GT              reduce using rule 50 (tempexpression -> RAND .)
    GE              reduce using rule 50 (tempexpression -> RAND .)
    RPAREN          reduce using rule 50 (tempexpression -> RAND .)
    COMMA           reduce using rule 50 (tempexpression -> RAND .)
    RBRACK          reduce using rule 50 (tempexpression -> RAND .)


state 6

    (27) expression -> NUMBER .
    (32) factor -> NUMBER .

  ! reduce/reduce conflict for COLON resolved using rule 27 (expression -> NUMBER .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 27 (expression -> NUMBER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 27 (expression -> NUMBER .)
    RPAREN          reduce using rule 27 (expression -> NUMBER .)
    ASSIGN          reduce using rule 27 (expression -> NUMBER .)
    ADD             reduce using rule 27 (expression -> NUMBER .)
    SUB             reduce using rule 27 (expression -> NUMBER .)
    MUL             reduce using rule 27 (expression -> NUMBER .)
    DIV             reduce using rule 27 (expression -> NUMBER .)
    MOD             reduce using rule 27 (expression -> NUMBER .)
    LT              reduce using rule 27 (expression -> NUMBER .)
    LE              reduce using rule 27 (expression -> NUMBER .)
    EQ              reduce using rule 27 (expression -> NUMBER .)
    NE              reduce using rule 27 (expression -> NUMBER .)
    GT              reduce using rule 27 (expression -> NUMBER .)
    GE              reduce using rule 27 (expression -> NUMBER .)
    COLON           reduce using rule 27 (expression -> NUMBER .)
    NEWLINE         reduce using rule 27 (expression -> NUMBER .)

  ! COLON           [ reduce using rule 32 (factor -> NUMBER .) ]
  ! NEWLINE         [ reduce using rule 32 (factor -> NUMBER .) ]
  ! RPAREN          [ reduce using rule 32 (factor -> NUMBER .) ]


state 7

    (43) pointer -> VAR .

    DECREMENT       reduce using rule 43 (pointer -> VAR .)
    INCREMENT       reduce using rule 43 (pointer -> VAR .)
    ASSIGN          reduce using rule 43 (pointer -> VAR .)
    COLON           reduce using rule 43 (pointer -> VAR .)
    NEWLINE         reduce using rule 43 (pointer -> VAR .)
    ADD             reduce using rule 43 (pointer -> VAR .)
    SUB             reduce using rule 43 (pointer -> VAR .)
    MUL             reduce using rule 43 (pointer -> VAR .)
    DIV             reduce using rule 43 (pointer -> VAR .)
    MOD             reduce using rule 43 (pointer -> VAR .)
    LT              reduce using rule 43 (pointer -> VAR .)
    LE              reduce using rule 43 (pointer -> VAR .)
    EQ              reduce using rule 43 (pointer -> VAR .)
    NE              reduce using rule 43 (pointer -> VAR .)
    GT              reduce using rule 43 (pointer -> VAR .)
    GE              reduce using rule 43 (pointer -> VAR .)
    RPAREN          reduce using rule 43 (pointer -> VAR .)
    RBRACK          reduce using rule 43 (pointer -> VAR .)
    COMMA           reduce using rule 43 (pointer -> VAR .)


state 8

    (21) control -> WHILE . expression newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    LPAREN          shift and go to state 30
    NUMBER          shift and go to state 32
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    tempexpression                 shift and go to state 29
    expression                     shift and go to state 34
    pointer                        shift and go to state 11

state 9

    (37) line -> meta .

    END             reduce using rule 37 (line -> meta .)
    COLON           reduce using rule 37 (line -> meta .)
    NEWLINE         reduce using rule 37 (line -> meta .)
    ID              reduce using rule 37 (line -> meta .)
    DISP            reduce using rule 37 (line -> meta .)
    PXL_ON          reduce using rule 37 (line -> meta .)
    IF              reduce using rule 37 (line -> meta .)
    REPEAT          reduce using rule 37 (line -> meta .)
    WHILE           reduce using rule 37 (line -> meta .)
    FOR             reduce using rule 37 (line -> meta .)
    LPAREN          reduce using rule 37 (line -> meta .)
    NUMBER          reduce using rule 37 (line -> meta .)
    SUB             reduce using rule 37 (line -> meta .)
    DEBUG           reduce using rule 37 (line -> meta .)
    EXIT            reduce using rule 37 (line -> meta .)
    VAR             reduce using rule 37 (line -> meta .)
    LBRACK          reduce using rule 37 (line -> meta .)
    CONST           reduce using rule 37 (line -> meta .)
    RAND            reduce using rule 37 (line -> meta .)
    $end            reduce using rule 37 (line -> meta .)


state 10

    (51) line -> PXL_ON . LPAREN expression COMMA expression RPAREN

    LPAREN          shift and go to state 35


state 11

    (23) expression -> pointer . DECREMENT
    (24) expression -> pointer . INCREMENT
    (49) tempexpression -> pointer .

    DECREMENT       shift and go to state 36
    INCREMENT       shift and go to state 37
    ASSIGN          reduce using rule 49 (tempexpression -> pointer .)
    COLON           reduce using rule 49 (tempexpression -> pointer .)
    NEWLINE         reduce using rule 49 (tempexpression -> pointer .)
    ADD             reduce using rule 49 (tempexpression -> pointer .)
    SUB             reduce using rule 49 (tempexpression -> pointer .)
    MUL             reduce using rule 49 (tempexpression -> pointer .)
    DIV             reduce using rule 49 (tempexpression -> pointer .)
    MOD             reduce using rule 49 (tempexpression -> pointer .)
    LT              reduce using rule 49 (tempexpression -> pointer .)
    LE              reduce using rule 49 (tempexpression -> pointer .)
    EQ              reduce using rule 49 (tempexpression -> pointer .)
    NE              reduce using rule 49 (tempexpression -> pointer .)
    GT              reduce using rule 49 (tempexpression -> pointer .)
    GE              reduce using rule 49 (tempexpression -> pointer .)
    RPAREN          reduce using rule 49 (tempexpression -> pointer .)
    COMMA           reduce using rule 49 (tempexpression -> pointer .)
    RBRACK          reduce using rule 49 (tempexpression -> pointer .)


state 12

    (6) newline -> NEWLINE .

    COLON           reduce using rule 6 (newline -> NEWLINE .)
    NEWLINE         reduce using rule 6 (newline -> NEWLINE .)
    ID              reduce using rule 6 (newline -> NEWLINE .)
    DISP            reduce using rule 6 (newline -> NEWLINE .)
    PXL_ON          reduce using rule 6 (newline -> NEWLINE .)
    IF              reduce using rule 6 (newline -> NEWLINE .)
    REPEAT          reduce using rule 6 (newline -> NEWLINE .)
    WHILE           reduce using rule 6 (newline -> NEWLINE .)
    FOR             reduce using rule 6 (newline -> NEWLINE .)
    LPAREN          reduce using rule 6 (newline -> NEWLINE .)
    NUMBER          reduce using rule 6 (newline -> NEWLINE .)
    SUB             reduce using rule 6 (newline -> NEWLINE .)
    DEBUG           reduce using rule 6 (newline -> NEWLINE .)
    EXIT            reduce using rule 6 (newline -> NEWLINE .)
    VAR             reduce using rule 6 (newline -> NEWLINE .)
    LBRACK          reduce using rule 6 (newline -> NEWLINE .)
    CONST           reduce using rule 6 (newline -> NEWLINE .)
    RAND            reduce using rule 6 (newline -> NEWLINE .)
    $end            reduce using rule 6 (newline -> NEWLINE .)
    END             reduce using rule 6 (newline -> NEWLINE .)


state 13

    (0) S' -> program .
    (46) program -> program . block
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 18
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 38

state 14

    (5) newline -> COLON .

    COLON           reduce using rule 5 (newline -> COLON .)
    NEWLINE         reduce using rule 5 (newline -> COLON .)
    ID              reduce using rule 5 (newline -> COLON .)
    DISP            reduce using rule 5 (newline -> COLON .)
    PXL_ON          reduce using rule 5 (newline -> COLON .)
    IF              reduce using rule 5 (newline -> COLON .)
    REPEAT          reduce using rule 5 (newline -> COLON .)
    WHILE           reduce using rule 5 (newline -> COLON .)
    FOR             reduce using rule 5 (newline -> COLON .)
    LPAREN          reduce using rule 5 (newline -> COLON .)
    NUMBER          reduce using rule 5 (newline -> COLON .)
    SUB             reduce using rule 5 (newline -> COLON .)
    DEBUG           reduce using rule 5 (newline -> COLON .)
    EXIT            reduce using rule 5 (newline -> COLON .)
    VAR             reduce using rule 5 (newline -> COLON .)
    LBRACK          reduce using rule 5 (newline -> COLON .)
    CONST           reduce using rule 5 (newline -> COLON .)
    RAND            reduce using rule 5 (newline -> COLON .)
    $end            reduce using rule 5 (newline -> COLON .)
    END             reduce using rule 5 (newline -> COLON .)


state 15

    (36) line -> factor . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

    newline                        shift and go to state 39

state 16

    (20) control -> REPEAT . expression newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    LPAREN          shift and go to state 30
    NUMBER          shift and go to state 32
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    tempexpression                 shift and go to state 29
    expression                     shift and go to state 40
    pointer                        shift and go to state 11

state 17

    (40) control -> FOR . LPAREN expression RPAREN newline block END newline
    (41) control -> FOR . LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline

    LPAREN          shift and go to state 41


state 18

    (2) block -> newline . block
    (18) newline -> newline . newline
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 42
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 43

state 19

    (26) expression -> LPAREN . expression RPAREN
    (29) factor -> LPAREN . factor RPAREN
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    pointer                        shift and go to state 11
    tempexpression                 shift and go to state 24
    expression                     shift and go to state 44
    factor                         shift and go to state 45

state 20

    (38) meta -> DEBUG . expression newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    LPAREN          shift and go to state 30
    NUMBER          shift and go to state 32
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    tempexpression                 shift and go to state 29
    expression                     shift and go to state 46
    pointer                        shift and go to state 11

state 21

    (3) block -> line .

    COLON           reduce using rule 3 (block -> line .)
    NEWLINE         reduce using rule 3 (block -> line .)
    ID              reduce using rule 3 (block -> line .)
    DISP            reduce using rule 3 (block -> line .)
    PXL_ON          reduce using rule 3 (block -> line .)
    IF              reduce using rule 3 (block -> line .)
    REPEAT          reduce using rule 3 (block -> line .)
    WHILE           reduce using rule 3 (block -> line .)
    FOR             reduce using rule 3 (block -> line .)
    LPAREN          reduce using rule 3 (block -> line .)
    NUMBER          reduce using rule 3 (block -> line .)
    SUB             reduce using rule 3 (block -> line .)
    DEBUG           reduce using rule 3 (block -> line .)
    EXIT            reduce using rule 3 (block -> line .)
    VAR             reduce using rule 3 (block -> line .)
    LBRACK          reduce using rule 3 (block -> line .)
    CONST           reduce using rule 3 (block -> line .)
    RAND            reduce using rule 3 (block -> line .)
    END             reduce using rule 3 (block -> line .)
    $end            reduce using rule 3 (block -> line .)


state 22

    (33) line -> ID .

    END             reduce using rule 33 (line -> ID .)
    COLON           reduce using rule 33 (line -> ID .)
    NEWLINE         reduce using rule 33 (line -> ID .)
    ID              reduce using rule 33 (line -> ID .)
    DISP            reduce using rule 33 (line -> ID .)
    PXL_ON          reduce using rule 33 (line -> ID .)
    IF              reduce using rule 33 (line -> ID .)
    REPEAT          reduce using rule 33 (line -> ID .)
    WHILE           reduce using rule 33 (line -> ID .)
    FOR             reduce using rule 33 (line -> ID .)
    LPAREN          reduce using rule 33 (line -> ID .)
    NUMBER          reduce using rule 33 (line -> ID .)
    SUB             reduce using rule 33 (line -> ID .)
    DEBUG           reduce using rule 33 (line -> ID .)
    EXIT            reduce using rule 33 (line -> ID .)
    VAR             reduce using rule 33 (line -> ID .)
    LBRACK          reduce using rule 33 (line -> ID .)
    CONST           reduce using rule 33 (line -> ID .)
    RAND            reduce using rule 33 (line -> ID .)
    $end            reduce using rule 33 (line -> ID .)


state 23

    (19) control -> IF . expression newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    LPAREN          shift and go to state 30
    NUMBER          shift and go to state 32
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    tempexpression                 shift and go to state 29
    expression                     shift and go to state 47
    pointer                        shift and go to state 11

state 24

    (28) expression -> tempexpression .
    (31) factor -> tempexpression .

  ! reduce/reduce conflict for COLON resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 28 (expression -> tempexpression .)
    RPAREN          reduce using rule 28 (expression -> tempexpression .)
    ASSIGN          reduce using rule 28 (expression -> tempexpression .)
    ADD             reduce using rule 28 (expression -> tempexpression .)
    SUB             reduce using rule 28 (expression -> tempexpression .)
    MUL             reduce using rule 28 (expression -> tempexpression .)
    DIV             reduce using rule 28 (expression -> tempexpression .)
    MOD             reduce using rule 28 (expression -> tempexpression .)
    LT              reduce using rule 28 (expression -> tempexpression .)
    LE              reduce using rule 28 (expression -> tempexpression .)
    EQ              reduce using rule 28 (expression -> tempexpression .)
    NE              reduce using rule 28 (expression -> tempexpression .)
    GT              reduce using rule 28 (expression -> tempexpression .)
    GE              reduce using rule 28 (expression -> tempexpression .)
    COLON           reduce using rule 28 (expression -> tempexpression .)
    NEWLINE         reduce using rule 28 (expression -> tempexpression .)

  ! COLON           [ reduce using rule 31 (factor -> tempexpression .) ]
  ! NEWLINE         [ reduce using rule 31 (factor -> tempexpression .) ]
  ! RPAREN          [ reduce using rule 31 (factor -> tempexpression .) ]


state 25

    (44) pointer -> LBRACK . expression RBRACK RMODIFIER
    (45) pointer -> LBRACK . expression RBRACK
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    LPAREN          shift and go to state 30
    NUMBER          shift and go to state 32
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    pointer                        shift and go to state 11
    tempexpression                 shift and go to state 29
    expression                     shift and go to state 48

state 26

    (39) meta -> EXIT . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

    newline                        shift and go to state 49

state 27

    (35) line -> expression . newline
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (30) factor -> expression .
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
    ASSIGN          shift and go to state 62
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

  ! COLON           [ reduce using rule 30 (factor -> expression .) ]
  ! NEWLINE         [ reduce using rule 30 (factor -> expression .) ]

    operator                       shift and go to state 59
    newline                        shift and go to state 54

state 28

    (47) program -> block .
    (1) block -> block . block
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for DISP resolved as shift
  ! shift/reduce conflict for PXL_ON resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for DEBUG resolved as shift
  ! shift/reduce conflict for EXIT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for LBRACK resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RAND resolved as shift
    $end            reduce using rule 47 (program -> block .)
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

  ! COLON           [ reduce using rule 47 (program -> block .) ]
  ! NEWLINE         [ reduce using rule 47 (program -> block .) ]
  ! ID              [ reduce using rule 47 (program -> block .) ]
  ! DISP            [ reduce using rule 47 (program -> block .) ]
  ! PXL_ON          [ reduce using rule 47 (program -> block .) ]
  ! IF              [ reduce using rule 47 (program -> block .) ]
  ! REPEAT          [ reduce using rule 47 (program -> block .) ]
  ! WHILE           [ reduce using rule 47 (program -> block .) ]
  ! FOR             [ reduce using rule 47 (program -> block .) ]
  ! LPAREN          [ reduce using rule 47 (program -> block .) ]
  ! NUMBER          [ reduce using rule 47 (program -> block .) ]
  ! SUB             [ reduce using rule 47 (program -> block .) ]
  ! DEBUG           [ reduce using rule 47 (program -> block .) ]
  ! EXIT            [ reduce using rule 47 (program -> block .) ]
  ! VAR             [ reduce using rule 47 (program -> block .) ]
  ! LBRACK          [ reduce using rule 47 (program -> block .) ]
  ! CONST           [ reduce using rule 47 (program -> block .) ]
  ! RAND            [ reduce using rule 47 (program -> block .) ]

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 18
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 64

state 29

    (28) expression -> tempexpression .

    RPAREN          reduce using rule 28 (expression -> tempexpression .)
    ASSIGN          reduce using rule 28 (expression -> tempexpression .)
    ADD             reduce using rule 28 (expression -> tempexpression .)
    SUB             reduce using rule 28 (expression -> tempexpression .)
    MUL             reduce using rule 28 (expression -> tempexpression .)
    DIV             reduce using rule 28 (expression -> tempexpression .)
    MOD             reduce using rule 28 (expression -> tempexpression .)
    LT              reduce using rule 28 (expression -> tempexpression .)
    LE              reduce using rule 28 (expression -> tempexpression .)
    EQ              reduce using rule 28 (expression -> tempexpression .)
    NE              reduce using rule 28 (expression -> tempexpression .)
    GT              reduce using rule 28 (expression -> tempexpression .)
    GE              reduce using rule 28 (expression -> tempexpression .)
    COLON           reduce using rule 28 (expression -> tempexpression .)
    NEWLINE         reduce using rule 28 (expression -> tempexpression .)
    RBRACK          reduce using rule 28 (expression -> tempexpression .)
    COMMA           reduce using rule 28 (expression -> tempexpression .)


state 30

    (26) expression -> LPAREN . expression RPAREN
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    LPAREN          shift and go to state 30
    NUMBER          shift and go to state 32
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    pointer                        shift and go to state 11
    tempexpression                 shift and go to state 29
    expression                     shift and go to state 65

state 31

    (34) line -> DISP expression . newline
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

    ASSIGN          shift and go to state 62
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

    operator                       shift and go to state 59
    newline                        shift and go to state 66

state 32

    (27) expression -> NUMBER .

    RPAREN          reduce using rule 27 (expression -> NUMBER .)
    ASSIGN          reduce using rule 27 (expression -> NUMBER .)
    ADD             reduce using rule 27 (expression -> NUMBER .)
    SUB             reduce using rule 27 (expression -> NUMBER .)
    MUL             reduce using rule 27 (expression -> NUMBER .)
    DIV             reduce using rule 27 (expression -> NUMBER .)
    MOD             reduce using rule 27 (expression -> NUMBER .)
    LT              reduce using rule 27 (expression -> NUMBER .)
    LE              reduce using rule 27 (expression -> NUMBER .)
    EQ              reduce using rule 27 (expression -> NUMBER .)
    NE              reduce using rule 27 (expression -> NUMBER .)
    GT              reduce using rule 27 (expression -> NUMBER .)
    GE              reduce using rule 27 (expression -> NUMBER .)
    COLON           reduce using rule 27 (expression -> NUMBER .)
    NEWLINE         reduce using rule 27 (expression -> NUMBER .)
    RBRACK          reduce using rule 27 (expression -> NUMBER .)
    COMMA           reduce using rule 27 (expression -> NUMBER .)


state 33

    (25) factor -> SUB expression .
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    COLON           reduce using rule 25 (factor -> SUB expression .)
    NEWLINE         reduce using rule 25 (factor -> SUB expression .)
    RPAREN          reduce using rule 25 (factor -> SUB expression .)
    RBRACK          reduce using rule 25 (factor -> SUB expression .)
    COMMA           reduce using rule 25 (factor -> SUB expression .)
    ASSIGN          shift and go to state 62
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

  ! ASSIGN          [ reduce using rule 25 (factor -> SUB expression .) ]
  ! ADD             [ reduce using rule 25 (factor -> SUB expression .) ]
  ! SUB             [ reduce using rule 25 (factor -> SUB expression .) ]
  ! MUL             [ reduce using rule 25 (factor -> SUB expression .) ]
  ! DIV             [ reduce using rule 25 (factor -> SUB expression .) ]
  ! MOD             [ reduce using rule 25 (factor -> SUB expression .) ]
  ! LT              [ reduce using rule 25 (factor -> SUB expression .) ]
  ! LE              [ reduce using rule 25 (factor -> SUB expression .) ]
  ! EQ              [ reduce using rule 25 (factor -> SUB expression .) ]
  ! NE              [ reduce using rule 25 (factor -> SUB expression .) ]
  ! GT              [ reduce using rule 25 (factor -> SUB expression .) ]
  ! GE              [ reduce using rule 25 (factor -> SUB expression .) ]

    operator                       shift and go to state 59

state 34

    (21) control -> WHILE expression . newline block END newline
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

    ASSIGN          shift and go to state 62
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

    newline                        shift and go to state 67
    operator                       shift and go to state 59

state 35

    (51) line -> PXL_ON LPAREN . expression COMMA expression RPAREN
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    LPAREN          shift and go to state 30
    NUMBER          shift and go to state 32
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    pointer                        shift and go to state 11
    tempexpression                 shift and go to state 29
    expression                     shift and go to state 68

state 36

    (23) expression -> pointer DECREMENT .

    RPAREN          reduce using rule 23 (expression -> pointer DECREMENT .)
    ASSIGN          reduce using rule 23 (expression -> pointer DECREMENT .)
    ADD             reduce using rule 23 (expression -> pointer DECREMENT .)
    SUB             reduce using rule 23 (expression -> pointer DECREMENT .)
    MUL             reduce using rule 23 (expression -> pointer DECREMENT .)
    DIV             reduce using rule 23 (expression -> pointer DECREMENT .)
    MOD             reduce using rule 23 (expression -> pointer DECREMENT .)
    LT              reduce using rule 23 (expression -> pointer DECREMENT .)
    LE              reduce using rule 23 (expression -> pointer DECREMENT .)
    EQ              reduce using rule 23 (expression -> pointer DECREMENT .)
    NE              reduce using rule 23 (expression -> pointer DECREMENT .)
    GT              reduce using rule 23 (expression -> pointer DECREMENT .)
    GE              reduce using rule 23 (expression -> pointer DECREMENT .)
    COLON           reduce using rule 23 (expression -> pointer DECREMENT .)
    NEWLINE         reduce using rule 23 (expression -> pointer DECREMENT .)
    RBRACK          reduce using rule 23 (expression -> pointer DECREMENT .)
    COMMA           reduce using rule 23 (expression -> pointer DECREMENT .)


state 37

    (24) expression -> pointer INCREMENT .

    RPAREN          reduce using rule 24 (expression -> pointer INCREMENT .)
    ASSIGN          reduce using rule 24 (expression -> pointer INCREMENT .)
    ADD             reduce using rule 24 (expression -> pointer INCREMENT .)
    SUB             reduce using rule 24 (expression -> pointer INCREMENT .)
    MUL             reduce using rule 24 (expression -> pointer INCREMENT .)
    DIV             reduce using rule 24 (expression -> pointer INCREMENT .)
    MOD             reduce using rule 24 (expression -> pointer INCREMENT .)
    LT              reduce using rule 24 (expression -> pointer INCREMENT .)
    LE              reduce using rule 24 (expression -> pointer INCREMENT .)
    EQ              reduce using rule 24 (expression -> pointer INCREMENT .)
    NE              reduce using rule 24 (expression -> pointer INCREMENT .)
    GT              reduce using rule 24 (expression -> pointer INCREMENT .)
    GE              reduce using rule 24 (expression -> pointer INCREMENT .)
    COLON           reduce using rule 24 (expression -> pointer INCREMENT .)
    NEWLINE         reduce using rule 24 (expression -> pointer INCREMENT .)
    RBRACK          reduce using rule 24 (expression -> pointer INCREMENT .)
    COMMA           reduce using rule 24 (expression -> pointer INCREMENT .)


state 38

    (46) program -> program block .
    (1) block -> block . block
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for DISP resolved as shift
  ! shift/reduce conflict for PXL_ON resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for DEBUG resolved as shift
  ! shift/reduce conflict for EXIT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for LBRACK resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RAND resolved as shift
    $end            reduce using rule 46 (program -> program block .)
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

  ! COLON           [ reduce using rule 46 (program -> program block .) ]
  ! NEWLINE         [ reduce using rule 46 (program -> program block .) ]
  ! ID              [ reduce using rule 46 (program -> program block .) ]
  ! DISP            [ reduce using rule 46 (program -> program block .) ]
  ! PXL_ON          [ reduce using rule 46 (program -> program block .) ]
  ! IF              [ reduce using rule 46 (program -> program block .) ]
  ! REPEAT          [ reduce using rule 46 (program -> program block .) ]
  ! WHILE           [ reduce using rule 46 (program -> program block .) ]
  ! FOR             [ reduce using rule 46 (program -> program block .) ]
  ! LPAREN          [ reduce using rule 46 (program -> program block .) ]
  ! NUMBER          [ reduce using rule 46 (program -> program block .) ]
  ! SUB             [ reduce using rule 46 (program -> program block .) ]
  ! DEBUG           [ reduce using rule 46 (program -> program block .) ]
  ! EXIT            [ reduce using rule 46 (program -> program block .) ]
  ! VAR             [ reduce using rule 46 (program -> program block .) ]
  ! LBRACK          [ reduce using rule 46 (program -> program block .) ]
  ! CONST           [ reduce using rule 46 (program -> program block .) ]
  ! RAND            [ reduce using rule 46 (program -> program block .) ]

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 18
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 64

state 39

    (36) line -> factor newline .
    (18) newline -> newline . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
    END             reduce using rule 36 (line -> factor newline .)
    ID              reduce using rule 36 (line -> factor newline .)
    DISP            reduce using rule 36 (line -> factor newline .)
    PXL_ON          reduce using rule 36 (line -> factor newline .)
    IF              reduce using rule 36 (line -> factor newline .)
    REPEAT          reduce using rule 36 (line -> factor newline .)
    WHILE           reduce using rule 36 (line -> factor newline .)
    FOR             reduce using rule 36 (line -> factor newline .)
    LPAREN          reduce using rule 36 (line -> factor newline .)
    NUMBER          reduce using rule 36 (line -> factor newline .)
    SUB             reduce using rule 36 (line -> factor newline .)
    DEBUG           reduce using rule 36 (line -> factor newline .)
    EXIT            reduce using rule 36 (line -> factor newline .)
    VAR             reduce using rule 36 (line -> factor newline .)
    LBRACK          reduce using rule 36 (line -> factor newline .)
    CONST           reduce using rule 36 (line -> factor newline .)
    RAND            reduce using rule 36 (line -> factor newline .)
    $end            reduce using rule 36 (line -> factor newline .)
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

  ! COLON           [ reduce using rule 36 (line -> factor newline .) ]
  ! NEWLINE         [ reduce using rule 36 (line -> factor newline .) ]

    newline                        shift and go to state 69

state 40

    (20) control -> REPEAT expression . newline block END newline
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

    ASSIGN          shift and go to state 62
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

    newline                        shift and go to state 70
    operator                       shift and go to state 59

state 41

    (40) control -> FOR LPAREN . expression RPAREN newline block END newline
    (41) control -> FOR LPAREN . pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    LPAREN          shift and go to state 30
    NUMBER          shift and go to state 32
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    tempexpression                 shift and go to state 29
    expression                     shift and go to state 72
    pointer                        shift and go to state 71

state 42

    (18) newline -> newline newline .
    (2) block -> newline . block
    (18) newline -> newline . newline
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for DISP resolved as shift
  ! shift/reduce conflict for PXL_ON resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for DEBUG resolved as shift
  ! shift/reduce conflict for EXIT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for LBRACK resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RAND resolved as shift
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

  ! COLON           [ reduce using rule 18 (newline -> newline newline .) ]
  ! NEWLINE         [ reduce using rule 18 (newline -> newline newline .) ]
  ! ID              [ reduce using rule 18 (newline -> newline newline .) ]
  ! DISP            [ reduce using rule 18 (newline -> newline newline .) ]
  ! PXL_ON          [ reduce using rule 18 (newline -> newline newline .) ]
  ! IF              [ reduce using rule 18 (newline -> newline newline .) ]
  ! REPEAT          [ reduce using rule 18 (newline -> newline newline .) ]
  ! WHILE           [ reduce using rule 18 (newline -> newline newline .) ]
  ! FOR             [ reduce using rule 18 (newline -> newline newline .) ]
  ! LPAREN          [ reduce using rule 18 (newline -> newline newline .) ]
  ! NUMBER          [ reduce using rule 18 (newline -> newline newline .) ]
  ! SUB             [ reduce using rule 18 (newline -> newline newline .) ]
  ! DEBUG           [ reduce using rule 18 (newline -> newline newline .) ]
  ! EXIT            [ reduce using rule 18 (newline -> newline newline .) ]
  ! VAR             [ reduce using rule 18 (newline -> newline newline .) ]
  ! LBRACK          [ reduce using rule 18 (newline -> newline newline .) ]
  ! CONST           [ reduce using rule 18 (newline -> newline newline .) ]
  ! RAND            [ reduce using rule 18 (newline -> newline newline .) ]

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 42
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 43

state 43

    (2) block -> newline block .
    (1) block -> block . block
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for DISP resolved as shift
  ! shift/reduce conflict for PXL_ON resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for DEBUG resolved as shift
  ! shift/reduce conflict for EXIT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for LBRACK resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RAND resolved as shift
    END             reduce using rule 2 (block -> newline block .)
    $end            reduce using rule 2 (block -> newline block .)
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

  ! COLON           [ reduce using rule 2 (block -> newline block .) ]
  ! NEWLINE         [ reduce using rule 2 (block -> newline block .) ]
  ! ID              [ reduce using rule 2 (block -> newline block .) ]
  ! DISP            [ reduce using rule 2 (block -> newline block .) ]
  ! PXL_ON          [ reduce using rule 2 (block -> newline block .) ]
  ! IF              [ reduce using rule 2 (block -> newline block .) ]
  ! REPEAT          [ reduce using rule 2 (block -> newline block .) ]
  ! WHILE           [ reduce using rule 2 (block -> newline block .) ]
  ! FOR             [ reduce using rule 2 (block -> newline block .) ]
  ! LPAREN          [ reduce using rule 2 (block -> newline block .) ]
  ! NUMBER          [ reduce using rule 2 (block -> newline block .) ]
  ! SUB             [ reduce using rule 2 (block -> newline block .) ]
  ! DEBUG           [ reduce using rule 2 (block -> newline block .) ]
  ! EXIT            [ reduce using rule 2 (block -> newline block .) ]
  ! VAR             [ reduce using rule 2 (block -> newline block .) ]
  ! LBRACK          [ reduce using rule 2 (block -> newline block .) ]
  ! CONST           [ reduce using rule 2 (block -> newline block .) ]
  ! RAND            [ reduce using rule 2 (block -> newline block .) ]

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 18
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 64

state 44

    (26) expression -> LPAREN expression . RPAREN
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (30) factor -> expression .
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 73
    ASSIGN          shift and go to state 62
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

  ! RPAREN          [ reduce using rule 30 (factor -> expression .) ]

    operator                       shift and go to state 59

state 45

    (29) factor -> LPAREN factor . RPAREN

    RPAREN          shift and go to state 74


state 46

    (38) meta -> DEBUG expression . newline
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

    ASSIGN          shift and go to state 62
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

    operator                       shift and go to state 59
    newline                        shift and go to state 75

state 47

    (19) control -> IF expression . newline block END newline
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

    ASSIGN          shift and go to state 62
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

    newline                        shift and go to state 76
    operator                       shift and go to state 59

state 48

    (44) pointer -> LBRACK expression . RBRACK RMODIFIER
    (45) pointer -> LBRACK expression . RBRACK
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

    RBRACK          shift and go to state 77
    ASSIGN          shift and go to state 62
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

    operator                       shift and go to state 59

state 49

    (39) meta -> EXIT newline .
    (18) newline -> newline . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
    ID              reduce using rule 39 (meta -> EXIT newline .)
    DISP            reduce using rule 39 (meta -> EXIT newline .)
    PXL_ON          reduce using rule 39 (meta -> EXIT newline .)
    IF              reduce using rule 39 (meta -> EXIT newline .)
    REPEAT          reduce using rule 39 (meta -> EXIT newline .)
    WHILE           reduce using rule 39 (meta -> EXIT newline .)
    FOR             reduce using rule 39 (meta -> EXIT newline .)
    LPAREN          reduce using rule 39 (meta -> EXIT newline .)
    NUMBER          reduce using rule 39 (meta -> EXIT newline .)
    SUB             reduce using rule 39 (meta -> EXIT newline .)
    DEBUG           reduce using rule 39 (meta -> EXIT newline .)
    EXIT            reduce using rule 39 (meta -> EXIT newline .)
    VAR             reduce using rule 39 (meta -> EXIT newline .)
    LBRACK          reduce using rule 39 (meta -> EXIT newline .)
    CONST           reduce using rule 39 (meta -> EXIT newline .)
    RAND            reduce using rule 39 (meta -> EXIT newline .)
    END             reduce using rule 39 (meta -> EXIT newline .)
    $end            reduce using rule 39 (meta -> EXIT newline .)
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

  ! COLON           [ reduce using rule 39 (meta -> EXIT newline .) ]
  ! NEWLINE         [ reduce using rule 39 (meta -> EXIT newline .) ]

    newline                        shift and go to state 69

state 50

    (17) operator -> GE .

    SUB             reduce using rule 17 (operator -> GE .)
    LPAREN          reduce using rule 17 (operator -> GE .)
    NUMBER          reduce using rule 17 (operator -> GE .)
    CONST           reduce using rule 17 (operator -> GE .)
    RAND            reduce using rule 17 (operator -> GE .)
    VAR             reduce using rule 17 (operator -> GE .)
    LBRACK          reduce using rule 17 (operator -> GE .)


state 51

    (16) operator -> GT .

    SUB             reduce using rule 16 (operator -> GT .)
    LPAREN          reduce using rule 16 (operator -> GT .)
    NUMBER          reduce using rule 16 (operator -> GT .)
    CONST           reduce using rule 16 (operator -> GT .)
    RAND            reduce using rule 16 (operator -> GT .)
    VAR             reduce using rule 16 (operator -> GT .)
    LBRACK          reduce using rule 16 (operator -> GT .)


state 52

    (14) operator -> EQ .

    SUB             reduce using rule 14 (operator -> EQ .)
    LPAREN          reduce using rule 14 (operator -> EQ .)
    NUMBER          reduce using rule 14 (operator -> EQ .)
    CONST           reduce using rule 14 (operator -> EQ .)
    RAND            reduce using rule 14 (operator -> EQ .)
    VAR             reduce using rule 14 (operator -> EQ .)
    LBRACK          reduce using rule 14 (operator -> EQ .)


state 53

    (8) operator -> SUB .

    SUB             reduce using rule 8 (operator -> SUB .)
    LPAREN          reduce using rule 8 (operator -> SUB .)
    NUMBER          reduce using rule 8 (operator -> SUB .)
    CONST           reduce using rule 8 (operator -> SUB .)
    RAND            reduce using rule 8 (operator -> SUB .)
    VAR             reduce using rule 8 (operator -> SUB .)
    LBRACK          reduce using rule 8 (operator -> SUB .)


state 54

    (35) line -> expression newline .
    (18) newline -> newline . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
    END             reduce using rule 35 (line -> expression newline .)
    ID              reduce using rule 35 (line -> expression newline .)
    DISP            reduce using rule 35 (line -> expression newline .)
    PXL_ON          reduce using rule 35 (line -> expression newline .)
    IF              reduce using rule 35 (line -> expression newline .)
    REPEAT          reduce using rule 35 (line -> expression newline .)
    WHILE           reduce using rule 35 (line -> expression newline .)
    FOR             reduce using rule 35 (line -> expression newline .)
    LPAREN          reduce using rule 35 (line -> expression newline .)
    NUMBER          reduce using rule 35 (line -> expression newline .)
    SUB             reduce using rule 35 (line -> expression newline .)
    DEBUG           reduce using rule 35 (line -> expression newline .)
    EXIT            reduce using rule 35 (line -> expression newline .)
    VAR             reduce using rule 35 (line -> expression newline .)
    LBRACK          reduce using rule 35 (line -> expression newline .)
    CONST           reduce using rule 35 (line -> expression newline .)
    RAND            reduce using rule 35 (line -> expression newline .)
    $end            reduce using rule 35 (line -> expression newline .)
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

  ! COLON           [ reduce using rule 35 (line -> expression newline .) ]
  ! NEWLINE         [ reduce using rule 35 (line -> expression newline .) ]

    newline                        shift and go to state 69

state 55

    (12) operator -> LT .

    SUB             reduce using rule 12 (operator -> LT .)
    LPAREN          reduce using rule 12 (operator -> LT .)
    NUMBER          reduce using rule 12 (operator -> LT .)
    CONST           reduce using rule 12 (operator -> LT .)
    RAND            reduce using rule 12 (operator -> LT .)
    VAR             reduce using rule 12 (operator -> LT .)
    LBRACK          reduce using rule 12 (operator -> LT .)


state 56

    (15) operator -> NE .

    SUB             reduce using rule 15 (operator -> NE .)
    LPAREN          reduce using rule 15 (operator -> NE .)
    NUMBER          reduce using rule 15 (operator -> NE .)
    CONST           reduce using rule 15 (operator -> NE .)
    RAND            reduce using rule 15 (operator -> NE .)
    VAR             reduce using rule 15 (operator -> NE .)
    LBRACK          reduce using rule 15 (operator -> NE .)


state 57

    (7) operator -> ADD .

    SUB             reduce using rule 7 (operator -> ADD .)
    LPAREN          reduce using rule 7 (operator -> ADD .)
    NUMBER          reduce using rule 7 (operator -> ADD .)
    CONST           reduce using rule 7 (operator -> ADD .)
    RAND            reduce using rule 7 (operator -> ADD .)
    VAR             reduce using rule 7 (operator -> ADD .)
    LBRACK          reduce using rule 7 (operator -> ADD .)


state 58

    (13) operator -> LE .

    SUB             reduce using rule 13 (operator -> LE .)
    LPAREN          reduce using rule 13 (operator -> LE .)
    NUMBER          reduce using rule 13 (operator -> LE .)
    CONST           reduce using rule 13 (operator -> LE .)
    RAND            reduce using rule 13 (operator -> LE .)
    VAR             reduce using rule 13 (operator -> LE .)
    LBRACK          reduce using rule 13 (operator -> LE .)


state 59

    (42) expression -> expression operator . factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK

    SUB             shift and go to state 4
    LPAREN          shift and go to state 80
    NUMBER          shift and go to state 79
    CONST           shift and go to state 3
    RAND            shift and go to state 5
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25

    pointer                        shift and go to state 11
    tempexpression                 shift and go to state 78
    expression                     shift and go to state 82
    factor                         shift and go to state 81

state 60

    (9) operator -> MUL .

    SUB             reduce using rule 9 (operator -> MUL .)
    LPAREN          reduce using rule 9 (operator -> MUL .)
    NUMBER          reduce using rule 9 (operator -> MUL .)
    CONST           reduce using rule 9 (operator -> MUL .)
    RAND            reduce using rule 9 (operator -> MUL .)
    VAR             reduce using rule 9 (operator -> MUL .)
    LBRACK          reduce using rule 9 (operator -> MUL .)


state 61

    (10) operator -> DIV .

    SUB             reduce using rule 10 (operator -> DIV .)
    LPAREN          reduce using rule 10 (operator -> DIV .)
    NUMBER          reduce using rule 10 (operator -> DIV .)
    CONST           reduce using rule 10 (operator -> DIV .)
    RAND            reduce using rule 10 (operator -> DIV .)
    VAR             reduce using rule 10 (operator -> DIV .)
    LBRACK          reduce using rule 10 (operator -> DIV .)


state 62

    (22) expression -> expression ASSIGN . pointer
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK

    VAR             shift and go to state 7
    LBRACK          shift and go to state 25

    pointer                        shift and go to state 83

state 63

    (11) operator -> MOD .

    SUB             reduce using rule 11 (operator -> MOD .)
    LPAREN          reduce using rule 11 (operator -> MOD .)
    NUMBER          reduce using rule 11 (operator -> MOD .)
    CONST           reduce using rule 11 (operator -> MOD .)
    RAND            reduce using rule 11 (operator -> MOD .)
    VAR             reduce using rule 11 (operator -> MOD .)
    LBRACK          reduce using rule 11 (operator -> MOD .)


state 64

    (1) block -> block block .
    (1) block -> block . block
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for DISP resolved as shift
  ! shift/reduce conflict for PXL_ON resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for DEBUG resolved as shift
  ! shift/reduce conflict for EXIT resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for LBRACK resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for RAND resolved as shift
    END             reduce using rule 1 (block -> block block .)
    $end            reduce using rule 1 (block -> block block .)
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

  ! COLON           [ reduce using rule 1 (block -> block block .) ]
  ! NEWLINE         [ reduce using rule 1 (block -> block block .) ]
  ! ID              [ reduce using rule 1 (block -> block block .) ]
  ! DISP            [ reduce using rule 1 (block -> block block .) ]
  ! PXL_ON          [ reduce using rule 1 (block -> block block .) ]
  ! IF              [ reduce using rule 1 (block -> block block .) ]
  ! REPEAT          [ reduce using rule 1 (block -> block block .) ]
  ! WHILE           [ reduce using rule 1 (block -> block block .) ]
  ! FOR             [ reduce using rule 1 (block -> block block .) ]
  ! LPAREN          [ reduce using rule 1 (block -> block block .) ]
  ! NUMBER          [ reduce using rule 1 (block -> block block .) ]
  ! SUB             [ reduce using rule 1 (block -> block block .) ]
  ! DEBUG           [ reduce using rule 1 (block -> block block .) ]
  ! EXIT            [ reduce using rule 1 (block -> block block .) ]
  ! VAR             [ reduce using rule 1 (block -> block block .) ]
  ! LBRACK          [ reduce using rule 1 (block -> block block .) ]
  ! CONST           [ reduce using rule 1 (block -> block block .) ]
  ! RAND            [ reduce using rule 1 (block -> block block .) ]

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 18
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 64

state 65

    (26) expression -> LPAREN expression . RPAREN
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

    RPAREN          shift and go to state 73
    ASSIGN          shift and go to state 62
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

    operator                       shift and go to state 59

state 66

    (34) line -> DISP expression newline .
    (18) newline -> newline . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
    END             reduce using rule 34 (line -> DISP expression newline .)
    ID              reduce using rule 34 (line -> DISP expression newline .)
    DISP            reduce using rule 34 (line -> DISP expression newline .)
    PXL_ON          reduce using rule 34 (line -> DISP expression newline .)
    IF              reduce using rule 34 (line -> DISP expression newline .)
    REPEAT          reduce using rule 34 (line -> DISP expression newline .)
    WHILE           reduce using rule 34 (line -> DISP expression newline .)
    FOR             reduce using rule 34 (line -> DISP expression newline .)
    LPAREN          reduce using rule 34 (line -> DISP expression newline .)
    NUMBER          reduce using rule 34 (line -> DISP expression newline .)
    SUB             reduce using rule 34 (line -> DISP expression newline .)
    DEBUG           reduce using rule 34 (line -> DISP expression newline .)
    EXIT            reduce using rule 34 (line -> DISP expression newline .)
    VAR             reduce using rule 34 (line -> DISP expression newline .)
    LBRACK          reduce using rule 34 (line -> DISP expression newline .)
    CONST           reduce using rule 34 (line -> DISP expression newline .)
    RAND            reduce using rule 34 (line -> DISP expression newline .)
    $end            reduce using rule 34 (line -> DISP expression newline .)
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

  ! COLON           [ reduce using rule 34 (line -> DISP expression newline .) ]
  ! NEWLINE         [ reduce using rule 34 (line -> DISP expression newline .) ]

    newline                        shift and go to state 69

state 67

    (21) control -> WHILE expression newline . block END newline
    (18) newline -> newline . newline
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 42
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 84

state 68

    (51) line -> PXL_ON LPAREN expression . COMMA expression RPAREN
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

    COMMA           shift and go to state 85
    ASSIGN          shift and go to state 62
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

    operator                       shift and go to state 59

state 69

    (18) newline -> newline newline .
    (18) newline -> newline . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
    ID              reduce using rule 18 (newline -> newline newline .)
    DISP            reduce using rule 18 (newline -> newline newline .)
    PXL_ON          reduce using rule 18 (newline -> newline newline .)
    IF              reduce using rule 18 (newline -> newline newline .)
    REPEAT          reduce using rule 18 (newline -> newline newline .)
    WHILE           reduce using rule 18 (newline -> newline newline .)
    FOR             reduce using rule 18 (newline -> newline newline .)
    LPAREN          reduce using rule 18 (newline -> newline newline .)
    NUMBER          reduce using rule 18 (newline -> newline newline .)
    SUB             reduce using rule 18 (newline -> newline newline .)
    DEBUG           reduce using rule 18 (newline -> newline newline .)
    EXIT            reduce using rule 18 (newline -> newline newline .)
    VAR             reduce using rule 18 (newline -> newline newline .)
    LBRACK          reduce using rule 18 (newline -> newline newline .)
    CONST           reduce using rule 18 (newline -> newline newline .)
    RAND            reduce using rule 18 (newline -> newline newline .)
    $end            reduce using rule 18 (newline -> newline newline .)
    END             reduce using rule 18 (newline -> newline newline .)
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

  ! COLON           [ reduce using rule 18 (newline -> newline newline .) ]
  ! NEWLINE         [ reduce using rule 18 (newline -> newline newline .) ]

    newline                        shift and go to state 69

state 70

    (20) control -> REPEAT expression newline . block END newline
    (18) newline -> newline . newline
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 42
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 86

state 71

    (41) control -> FOR LPAREN pointer . COMMA expression COMMA expression RPAREN newline block END newline
    (23) expression -> pointer . DECREMENT
    (24) expression -> pointer . INCREMENT
    (49) tempexpression -> pointer .

    COMMA           shift and go to state 87
    DECREMENT       shift and go to state 36
    INCREMENT       shift and go to state 37
    RPAREN          reduce using rule 49 (tempexpression -> pointer .)
    ASSIGN          reduce using rule 49 (tempexpression -> pointer .)
    ADD             reduce using rule 49 (tempexpression -> pointer .)
    SUB             reduce using rule 49 (tempexpression -> pointer .)
    MUL             reduce using rule 49 (tempexpression -> pointer .)
    DIV             reduce using rule 49 (tempexpression -> pointer .)
    MOD             reduce using rule 49 (tempexpression -> pointer .)
    LT              reduce using rule 49 (tempexpression -> pointer .)
    LE              reduce using rule 49 (tempexpression -> pointer .)
    EQ              reduce using rule 49 (tempexpression -> pointer .)
    NE              reduce using rule 49 (tempexpression -> pointer .)
    GT              reduce using rule 49 (tempexpression -> pointer .)
    GE              reduce using rule 49 (tempexpression -> pointer .)


state 72

    (40) control -> FOR LPAREN expression . RPAREN newline block END newline
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

    RPAREN          shift and go to state 88
    ASSIGN          shift and go to state 62
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

    operator                       shift and go to state 59

state 73

    (26) expression -> LPAREN expression RPAREN .

    RPAREN          reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    ASSIGN          reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    ADD             reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    SUB             reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    MUL             reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    DIV             reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    MOD             reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    NE              reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    COLON           reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    NEWLINE         reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    RBRACK          reduce using rule 26 (expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 26 (expression -> LPAREN expression RPAREN .)


state 74

    (29) factor -> LPAREN factor RPAREN .

    COLON           reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    NEWLINE         reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    RPAREN          reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    ASSIGN          reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    ADD             reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    SUB             reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    MUL             reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    DIV             reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    MOD             reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    LT              reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    LE              reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    EQ              reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    NE              reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    GT              reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    GE              reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    RBRACK          reduce using rule 29 (factor -> LPAREN factor RPAREN .)
    COMMA           reduce using rule 29 (factor -> LPAREN factor RPAREN .)


state 75

    (38) meta -> DEBUG expression newline .
    (18) newline -> newline . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
    ID              reduce using rule 38 (meta -> DEBUG expression newline .)
    DISP            reduce using rule 38 (meta -> DEBUG expression newline .)
    PXL_ON          reduce using rule 38 (meta -> DEBUG expression newline .)
    IF              reduce using rule 38 (meta -> DEBUG expression newline .)
    REPEAT          reduce using rule 38 (meta -> DEBUG expression newline .)
    WHILE           reduce using rule 38 (meta -> DEBUG expression newline .)
    FOR             reduce using rule 38 (meta -> DEBUG expression newline .)
    LPAREN          reduce using rule 38 (meta -> DEBUG expression newline .)
    NUMBER          reduce using rule 38 (meta -> DEBUG expression newline .)
    SUB             reduce using rule 38 (meta -> DEBUG expression newline .)
    DEBUG           reduce using rule 38 (meta -> DEBUG expression newline .)
    EXIT            reduce using rule 38 (meta -> DEBUG expression newline .)
    VAR             reduce using rule 38 (meta -> DEBUG expression newline .)
    LBRACK          reduce using rule 38 (meta -> DEBUG expression newline .)
    CONST           reduce using rule 38 (meta -> DEBUG expression newline .)
    RAND            reduce using rule 38 (meta -> DEBUG expression newline .)
    END             reduce using rule 38 (meta -> DEBUG expression newline .)
    $end            reduce using rule 38 (meta -> DEBUG expression newline .)
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

  ! COLON           [ reduce using rule 38 (meta -> DEBUG expression newline .) ]
  ! NEWLINE         [ reduce using rule 38 (meta -> DEBUG expression newline .) ]

    newline                        shift and go to state 69

state 76

    (19) control -> IF expression newline . block END newline
    (18) newline -> newline . newline
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 42
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 89

state 77

    (44) pointer -> LBRACK expression RBRACK . RMODIFIER
    (45) pointer -> LBRACK expression RBRACK .

    RMODIFIER       shift and go to state 90
    DECREMENT       reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    INCREMENT       reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    ASSIGN          reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    COLON           reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    NEWLINE         reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    ADD             reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    SUB             reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    MUL             reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    DIV             reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    MOD             reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    LT              reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    LE              reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    EQ              reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    NE              reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    GT              reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    GE              reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    RPAREN          reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    RBRACK          reduce using rule 45 (pointer -> LBRACK expression RBRACK .)
    COMMA           reduce using rule 45 (pointer -> LBRACK expression RBRACK .)


state 78

    (31) factor -> tempexpression .
    (28) expression -> tempexpression .

  ! reduce/reduce conflict for ASSIGN resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for ADD resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for SUB resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for MUL resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for DIV resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for MOD resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for LT resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for LE resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for EQ resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for NE resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for GT resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for GE resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for COLON resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for RPAREN resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for RBRACK resolved using rule 28 (expression -> tempexpression .)
  ! reduce/reduce conflict for COMMA resolved using rule 28 (expression -> tempexpression .)
    ASSIGN          reduce using rule 28 (expression -> tempexpression .)
    ADD             reduce using rule 28 (expression -> tempexpression .)
    SUB             reduce using rule 28 (expression -> tempexpression .)
    MUL             reduce using rule 28 (expression -> tempexpression .)
    DIV             reduce using rule 28 (expression -> tempexpression .)
    MOD             reduce using rule 28 (expression -> tempexpression .)
    LT              reduce using rule 28 (expression -> tempexpression .)
    LE              reduce using rule 28 (expression -> tempexpression .)
    EQ              reduce using rule 28 (expression -> tempexpression .)
    NE              reduce using rule 28 (expression -> tempexpression .)
    GT              reduce using rule 28 (expression -> tempexpression .)
    GE              reduce using rule 28 (expression -> tempexpression .)
    COLON           reduce using rule 28 (expression -> tempexpression .)
    NEWLINE         reduce using rule 28 (expression -> tempexpression .)
    RPAREN          reduce using rule 28 (expression -> tempexpression .)
    RBRACK          reduce using rule 28 (expression -> tempexpression .)
    COMMA           reduce using rule 28 (expression -> tempexpression .)

  ! ASSIGN          [ reduce using rule 31 (factor -> tempexpression .) ]
  ! ADD             [ reduce using rule 31 (factor -> tempexpression .) ]
  ! SUB             [ reduce using rule 31 (factor -> tempexpression .) ]
  ! MUL             [ reduce using rule 31 (factor -> tempexpression .) ]
  ! DIV             [ reduce using rule 31 (factor -> tempexpression .) ]
  ! MOD             [ reduce using rule 31 (factor -> tempexpression .) ]
  ! LT              [ reduce using rule 31 (factor -> tempexpression .) ]
  ! LE              [ reduce using rule 31 (factor -> tempexpression .) ]
  ! EQ              [ reduce using rule 31 (factor -> tempexpression .) ]
  ! NE              [ reduce using rule 31 (factor -> tempexpression .) ]
  ! GT              [ reduce using rule 31 (factor -> tempexpression .) ]
  ! GE              [ reduce using rule 31 (factor -> tempexpression .) ]
  ! COLON           [ reduce using rule 31 (factor -> tempexpression .) ]
  ! NEWLINE         [ reduce using rule 31 (factor -> tempexpression .) ]
  ! RPAREN          [ reduce using rule 31 (factor -> tempexpression .) ]
  ! RBRACK          [ reduce using rule 31 (factor -> tempexpression .) ]
  ! COMMA           [ reduce using rule 31 (factor -> tempexpression .) ]


state 79

    (32) factor -> NUMBER .
    (27) expression -> NUMBER .

  ! reduce/reduce conflict for ASSIGN resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for ADD resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for SUB resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for MUL resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for DIV resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for MOD resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for LT resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for LE resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for NE resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for GT resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for GE resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for COLON resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for RBRACK resolved using rule 32 (factor -> NUMBER .)
  ! reduce/reduce conflict for COMMA resolved using rule 32 (factor -> NUMBER .)
    ASSIGN          reduce using rule 32 (factor -> NUMBER .)
    ADD             reduce using rule 32 (factor -> NUMBER .)
    SUB             reduce using rule 32 (factor -> NUMBER .)
    MUL             reduce using rule 32 (factor -> NUMBER .)
    DIV             reduce using rule 32 (factor -> NUMBER .)
    MOD             reduce using rule 32 (factor -> NUMBER .)
    LT              reduce using rule 32 (factor -> NUMBER .)
    LE              reduce using rule 32 (factor -> NUMBER .)
    EQ              reduce using rule 32 (factor -> NUMBER .)
    NE              reduce using rule 32 (factor -> NUMBER .)
    GT              reduce using rule 32 (factor -> NUMBER .)
    GE              reduce using rule 32 (factor -> NUMBER .)
    COLON           reduce using rule 32 (factor -> NUMBER .)
    NEWLINE         reduce using rule 32 (factor -> NUMBER .)
    RPAREN          reduce using rule 32 (factor -> NUMBER .)
    RBRACK          reduce using rule 32 (factor -> NUMBER .)
    COMMA           reduce using rule 32 (factor -> NUMBER .)

  ! ASSIGN          [ reduce using rule 27 (expression -> NUMBER .) ]
  ! ADD             [ reduce using rule 27 (expression -> NUMBER .) ]
  ! SUB             [ reduce using rule 27 (expression -> NUMBER .) ]
  ! MUL             [ reduce using rule 27 (expression -> NUMBER .) ]
  ! DIV             [ reduce using rule 27 (expression -> NUMBER .) ]
  ! MOD             [ reduce using rule 27 (expression -> NUMBER .) ]
  ! LT              [ reduce using rule 27 (expression -> NUMBER .) ]
  ! LE              [ reduce using rule 27 (expression -> NUMBER .) ]
  ! EQ              [ reduce using rule 27 (expression -> NUMBER .) ]
  ! NE              [ reduce using rule 27 (expression -> NUMBER .) ]
  ! GT              [ reduce using rule 27 (expression -> NUMBER .) ]
  ! GE              [ reduce using rule 27 (expression -> NUMBER .) ]
  ! COLON           [ reduce using rule 27 (expression -> NUMBER .) ]
  ! NEWLINE         [ reduce using rule 27 (expression -> NUMBER .) ]
  ! RPAREN          [ reduce using rule 27 (expression -> NUMBER .) ]
  ! RBRACK          [ reduce using rule 27 (expression -> NUMBER .) ]
  ! COMMA           [ reduce using rule 27 (expression -> NUMBER .) ]


state 80

    (29) factor -> LPAREN . factor RPAREN
    (26) expression -> LPAREN . expression RPAREN
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK

    SUB             shift and go to state 4
    LPAREN          shift and go to state 80
    NUMBER          shift and go to state 79
    CONST           shift and go to state 3
    RAND            shift and go to state 5
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25

    pointer                        shift and go to state 11
    tempexpression                 shift and go to state 78
    expression                     shift and go to state 91
    factor                         shift and go to state 45

state 81

    (42) expression -> expression operator factor .

    RPAREN          reduce using rule 42 (expression -> expression operator factor .)
    ASSIGN          reduce using rule 42 (expression -> expression operator factor .)
    ADD             reduce using rule 42 (expression -> expression operator factor .)
    SUB             reduce using rule 42 (expression -> expression operator factor .)
    MUL             reduce using rule 42 (expression -> expression operator factor .)
    DIV             reduce using rule 42 (expression -> expression operator factor .)
    MOD             reduce using rule 42 (expression -> expression operator factor .)
    LT              reduce using rule 42 (expression -> expression operator factor .)
    LE              reduce using rule 42 (expression -> expression operator factor .)
    EQ              reduce using rule 42 (expression -> expression operator factor .)
    NE              reduce using rule 42 (expression -> expression operator factor .)
    GT              reduce using rule 42 (expression -> expression operator factor .)
    GE              reduce using rule 42 (expression -> expression operator factor .)
    COLON           reduce using rule 42 (expression -> expression operator factor .)
    NEWLINE         reduce using rule 42 (expression -> expression operator factor .)
    RBRACK          reduce using rule 42 (expression -> expression operator factor .)
    COMMA           reduce using rule 42 (expression -> expression operator factor .)


state 82

    (30) factor -> expression .
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for ADD resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    COLON           reduce using rule 30 (factor -> expression .)
    NEWLINE         reduce using rule 30 (factor -> expression .)
    RPAREN          reduce using rule 30 (factor -> expression .)
    RBRACK          reduce using rule 30 (factor -> expression .)
    COMMA           reduce using rule 30 (factor -> expression .)
    ASSIGN          shift and go to state 62
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

  ! ASSIGN          [ reduce using rule 30 (factor -> expression .) ]
  ! ADD             [ reduce using rule 30 (factor -> expression .) ]
  ! SUB             [ reduce using rule 30 (factor -> expression .) ]
  ! MUL             [ reduce using rule 30 (factor -> expression .) ]
  ! DIV             [ reduce using rule 30 (factor -> expression .) ]
  ! MOD             [ reduce using rule 30 (factor -> expression .) ]
  ! LT              [ reduce using rule 30 (factor -> expression .) ]
  ! LE              [ reduce using rule 30 (factor -> expression .) ]
  ! EQ              [ reduce using rule 30 (factor -> expression .) ]
  ! NE              [ reduce using rule 30 (factor -> expression .) ]
  ! GT              [ reduce using rule 30 (factor -> expression .) ]
  ! GE              [ reduce using rule 30 (factor -> expression .) ]

    operator                       shift and go to state 59

state 83

    (22) expression -> expression ASSIGN pointer .

    RPAREN          reduce using rule 22 (expression -> expression ASSIGN pointer .)
    ASSIGN          reduce using rule 22 (expression -> expression ASSIGN pointer .)
    ADD             reduce using rule 22 (expression -> expression ASSIGN pointer .)
    SUB             reduce using rule 22 (expression -> expression ASSIGN pointer .)
    MUL             reduce using rule 22 (expression -> expression ASSIGN pointer .)
    DIV             reduce using rule 22 (expression -> expression ASSIGN pointer .)
    MOD             reduce using rule 22 (expression -> expression ASSIGN pointer .)
    LT              reduce using rule 22 (expression -> expression ASSIGN pointer .)
    LE              reduce using rule 22 (expression -> expression ASSIGN pointer .)
    EQ              reduce using rule 22 (expression -> expression ASSIGN pointer .)
    NE              reduce using rule 22 (expression -> expression ASSIGN pointer .)
    GT              reduce using rule 22 (expression -> expression ASSIGN pointer .)
    GE              reduce using rule 22 (expression -> expression ASSIGN pointer .)
    COLON           reduce using rule 22 (expression -> expression ASSIGN pointer .)
    NEWLINE         reduce using rule 22 (expression -> expression ASSIGN pointer .)
    RBRACK          reduce using rule 22 (expression -> expression ASSIGN pointer .)
    COMMA           reduce using rule 22 (expression -> expression ASSIGN pointer .)


state 84

    (21) control -> WHILE expression newline block . END newline
    (1) block -> block . block
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    END             shift and go to state 92
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 18
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 64

state 85

    (51) line -> PXL_ON LPAREN expression COMMA . expression RPAREN
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    LPAREN          shift and go to state 30
    NUMBER          shift and go to state 32
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    pointer                        shift and go to state 11
    tempexpression                 shift and go to state 29
    expression                     shift and go to state 93

state 86

    (20) control -> REPEAT expression newline block . END newline
    (1) block -> block . block
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    END             shift and go to state 94
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 18
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 64

state 87

    (41) control -> FOR LPAREN pointer COMMA . expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    LPAREN          shift and go to state 30
    NUMBER          shift and go to state 32
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    tempexpression                 shift and go to state 29
    pointer                        shift and go to state 11
    expression                     shift and go to state 95

state 88

    (40) control -> FOR LPAREN expression RPAREN . newline block END newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

    newline                        shift and go to state 96

state 89

    (19) control -> IF expression newline block . END newline
    (1) block -> block . block
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    END             shift and go to state 97
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 18
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 64

state 90

    (44) pointer -> LBRACK expression RBRACK RMODIFIER .

    DECREMENT       reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    INCREMENT       reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    ASSIGN          reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    COLON           reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    NEWLINE         reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    ADD             reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    SUB             reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    MUL             reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    DIV             reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    MOD             reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    LT              reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    LE              reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    EQ              reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    NE              reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    GT              reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    GE              reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    RPAREN          reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    RBRACK          reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)
    COMMA           reduce using rule 44 (pointer -> LBRACK expression RBRACK RMODIFIER .)


state 91

    (26) expression -> LPAREN expression . RPAREN
    (30) factor -> expression .
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 73
    ASSIGN          shift and go to state 62
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

  ! RPAREN          [ reduce using rule 30 (factor -> expression .) ]

    operator                       shift and go to state 59

state 92

    (21) control -> WHILE expression newline block END . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

    newline                        shift and go to state 98

state 93

    (51) line -> PXL_ON LPAREN expression COMMA expression . RPAREN
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

    RPAREN          shift and go to state 99
    ASSIGN          shift and go to state 62
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

    operator                       shift and go to state 59

state 94

    (20) control -> REPEAT expression newline block END . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

    newline                        shift and go to state 100

state 95

    (41) control -> FOR LPAREN pointer COMMA expression . COMMA expression RPAREN newline block END newline
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

    COMMA           shift and go to state 101
    ASSIGN          shift and go to state 62
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

    operator                       shift and go to state 59

state 96

    (40) control -> FOR LPAREN expression RPAREN newline . block END newline
    (18) newline -> newline . newline
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 42
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 102

state 97

    (19) control -> IF expression newline block END . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

    newline                        shift and go to state 103

state 98

    (21) control -> WHILE expression newline block END newline .
    (18) newline -> newline . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
    END             reduce using rule 21 (control -> WHILE expression newline block END newline .)
    ID              reduce using rule 21 (control -> WHILE expression newline block END newline .)
    DISP            reduce using rule 21 (control -> WHILE expression newline block END newline .)
    PXL_ON          reduce using rule 21 (control -> WHILE expression newline block END newline .)
    IF              reduce using rule 21 (control -> WHILE expression newline block END newline .)
    REPEAT          reduce using rule 21 (control -> WHILE expression newline block END newline .)
    WHILE           reduce using rule 21 (control -> WHILE expression newline block END newline .)
    FOR             reduce using rule 21 (control -> WHILE expression newline block END newline .)
    LPAREN          reduce using rule 21 (control -> WHILE expression newline block END newline .)
    NUMBER          reduce using rule 21 (control -> WHILE expression newline block END newline .)
    SUB             reduce using rule 21 (control -> WHILE expression newline block END newline .)
    DEBUG           reduce using rule 21 (control -> WHILE expression newline block END newline .)
    EXIT            reduce using rule 21 (control -> WHILE expression newline block END newline .)
    VAR             reduce using rule 21 (control -> WHILE expression newline block END newline .)
    LBRACK          reduce using rule 21 (control -> WHILE expression newline block END newline .)
    CONST           reduce using rule 21 (control -> WHILE expression newline block END newline .)
    RAND            reduce using rule 21 (control -> WHILE expression newline block END newline .)
    $end            reduce using rule 21 (control -> WHILE expression newline block END newline .)
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

  ! COLON           [ reduce using rule 21 (control -> WHILE expression newline block END newline .) ]
  ! NEWLINE         [ reduce using rule 21 (control -> WHILE expression newline block END newline .) ]

    newline                        shift and go to state 69

state 99

    (51) line -> PXL_ON LPAREN expression COMMA expression RPAREN .

    END             reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    COLON           reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    NEWLINE         reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    ID              reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    DISP            reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    PXL_ON          reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    IF              reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    REPEAT          reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    WHILE           reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    FOR             reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    LPAREN          reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    NUMBER          reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    SUB             reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    DEBUG           reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    EXIT            reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    VAR             reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    LBRACK          reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    CONST           reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    RAND            reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)
    $end            reduce using rule 51 (line -> PXL_ON LPAREN expression COMMA expression RPAREN .)


state 100

    (20) control -> REPEAT expression newline block END newline .
    (18) newline -> newline . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
    END             reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    ID              reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    DISP            reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    PXL_ON          reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    IF              reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    REPEAT          reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    WHILE           reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    FOR             reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    LPAREN          reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    NUMBER          reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    SUB             reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    DEBUG           reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    EXIT            reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    VAR             reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    LBRACK          reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    CONST           reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    RAND            reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    $end            reduce using rule 20 (control -> REPEAT expression newline block END newline .)
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

  ! COLON           [ reduce using rule 20 (control -> REPEAT expression newline block END newline .) ]
  ! NEWLINE         [ reduce using rule 20 (control -> REPEAT expression newline block END newline .) ]

    newline                        shift and go to state 69

state 101

    (41) control -> FOR LPAREN pointer COMMA expression COMMA . expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    LPAREN          shift and go to state 30
    NUMBER          shift and go to state 32
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    tempexpression                 shift and go to state 29
    pointer                        shift and go to state 11
    expression                     shift and go to state 104

state 102

    (40) control -> FOR LPAREN expression RPAREN newline block . END newline
    (1) block -> block . block
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    END             shift and go to state 105
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 18
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 64

state 103

    (19) control -> IF expression newline block END newline .
    (18) newline -> newline . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
    END             reduce using rule 19 (control -> IF expression newline block END newline .)
    ID              reduce using rule 19 (control -> IF expression newline block END newline .)
    DISP            reduce using rule 19 (control -> IF expression newline block END newline .)
    PXL_ON          reduce using rule 19 (control -> IF expression newline block END newline .)
    IF              reduce using rule 19 (control -> IF expression newline block END newline .)
    REPEAT          reduce using rule 19 (control -> IF expression newline block END newline .)
    WHILE           reduce using rule 19 (control -> IF expression newline block END newline .)
    FOR             reduce using rule 19 (control -> IF expression newline block END newline .)
    LPAREN          reduce using rule 19 (control -> IF expression newline block END newline .)
    NUMBER          reduce using rule 19 (control -> IF expression newline block END newline .)
    SUB             reduce using rule 19 (control -> IF expression newline block END newline .)
    DEBUG           reduce using rule 19 (control -> IF expression newline block END newline .)
    EXIT            reduce using rule 19 (control -> IF expression newline block END newline .)
    VAR             reduce using rule 19 (control -> IF expression newline block END newline .)
    LBRACK          reduce using rule 19 (control -> IF expression newline block END newline .)
    CONST           reduce using rule 19 (control -> IF expression newline block END newline .)
    RAND            reduce using rule 19 (control -> IF expression newline block END newline .)
    $end            reduce using rule 19 (control -> IF expression newline block END newline .)
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

  ! COLON           [ reduce using rule 19 (control -> IF expression newline block END newline .) ]
  ! NEWLINE         [ reduce using rule 19 (control -> IF expression newline block END newline .) ]

    newline                        shift and go to state 69

state 104

    (41) control -> FOR LPAREN pointer COMMA expression COMMA expression . RPAREN newline block END newline
    (22) expression -> expression . ASSIGN pointer
    (42) expression -> expression . operator factor
    (7) operator -> . ADD
    (8) operator -> . SUB
    (9) operator -> . MUL
    (10) operator -> . DIV
    (11) operator -> . MOD
    (12) operator -> . LT
    (13) operator -> . LE
    (14) operator -> . EQ
    (15) operator -> . NE
    (16) operator -> . GT
    (17) operator -> . GE

    RPAREN          shift and go to state 106
    ASSIGN          shift and go to state 62
    ADD             shift and go to state 57
    SUB             shift and go to state 53
    MUL             shift and go to state 60
    DIV             shift and go to state 61
    MOD             shift and go to state 63
    LT              shift and go to state 55
    LE              shift and go to state 58
    EQ              shift and go to state 52
    NE              shift and go to state 56
    GT              shift and go to state 51
    GE              shift and go to state 50

    operator                       shift and go to state 59

state 105

    (40) control -> FOR LPAREN expression RPAREN newline block END . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

    newline                        shift and go to state 107

state 106

    (41) control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN . newline block END newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

    newline                        shift and go to state 108

state 107

    (40) control -> FOR LPAREN expression RPAREN newline block END newline .
    (18) newline -> newline . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
    END             reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    ID              reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    DISP            reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    PXL_ON          reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    IF              reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    REPEAT          reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    WHILE           reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    FOR             reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    LPAREN          reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    NUMBER          reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    SUB             reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    DEBUG           reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    EXIT            reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    VAR             reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    LBRACK          reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    CONST           reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    RAND            reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    $end            reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .)
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

  ! COLON           [ reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .) ]
  ! NEWLINE         [ reduce using rule 40 (control -> FOR LPAREN expression RPAREN newline block END newline .) ]

    newline                        shift and go to state 69

state 108

    (41) control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline . block END newline
    (18) newline -> newline . newline
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 42
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 109

state 109

    (41) control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block . END newline
    (1) block -> block . block
    (1) block -> . block block
    (2) block -> . newline block
    (3) block -> . line
    (4) block -> . control
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline
    (33) line -> . ID
    (34) line -> . DISP expression newline
    (35) line -> . expression newline
    (36) line -> . factor newline
    (37) line -> . meta
    (51) line -> . PXL_ON LPAREN expression COMMA expression RPAREN
    (19) control -> . IF expression newline block END newline
    (20) control -> . REPEAT expression newline block END newline
    (21) control -> . WHILE expression newline block END newline
    (40) control -> . FOR LPAREN expression RPAREN newline block END newline
    (41) control -> . FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline
    (22) expression -> . expression ASSIGN pointer
    (23) expression -> . pointer DECREMENT
    (24) expression -> . pointer INCREMENT
    (26) expression -> . LPAREN expression RPAREN
    (27) expression -> . NUMBER
    (28) expression -> . tempexpression
    (42) expression -> . expression operator factor
    (25) factor -> . SUB expression
    (29) factor -> . LPAREN factor RPAREN
    (30) factor -> . expression
    (31) factor -> . tempexpression
    (32) factor -> . NUMBER
    (38) meta -> . DEBUG expression newline
    (39) meta -> . EXIT newline
    (43) pointer -> . VAR
    (44) pointer -> . LBRACK expression RBRACK RMODIFIER
    (45) pointer -> . LBRACK expression RBRACK
    (48) tempexpression -> . CONST
    (49) tempexpression -> . pointer
    (50) tempexpression -> . RAND

    END             shift and go to state 110
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12
    ID              shift and go to state 22
    DISP            shift and go to state 2
    PXL_ON          shift and go to state 10
    IF              shift and go to state 23
    REPEAT          shift and go to state 16
    WHILE           shift and go to state 8
    FOR             shift and go to state 17
    LPAREN          shift and go to state 19
    NUMBER          shift and go to state 6
    SUB             shift and go to state 4
    DEBUG           shift and go to state 20
    EXIT            shift and go to state 26
    VAR             shift and go to state 7
    LBRACK          shift and go to state 25
    CONST           shift and go to state 3
    RAND            shift and go to state 5

    control                        shift and go to state 1
    tempexpression                 shift and go to state 24
    pointer                        shift and go to state 11
    newline                        shift and go to state 18
    meta                           shift and go to state 9
    factor                         shift and go to state 15
    line                           shift and go to state 21
    expression                     shift and go to state 27
    block                          shift and go to state 64

state 110

    (41) control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

    newline                        shift and go to state 111

state 111

    (41) control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .
    (18) newline -> newline . newline
    (5) newline -> . COLON
    (6) newline -> . NEWLINE
    (18) newline -> . newline newline

  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for NEWLINE resolved as shift
    END             reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    ID              reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    DISP            reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    PXL_ON          reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    IF              reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    REPEAT          reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    WHILE           reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    FOR             reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    LPAREN          reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    NUMBER          reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    SUB             reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    DEBUG           reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    EXIT            reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    VAR             reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    LBRACK          reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    CONST           reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    RAND            reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    $end            reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .)
    COLON           shift and go to state 14
    NEWLINE         shift and go to state 12

  ! COLON           [ reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .) ]
  ! NEWLINE         [ reduce using rule 41 (control -> FOR LPAREN pointer COMMA expression COMMA expression RPAREN newline block END newline .) ]

    newline                        shift and go to state 69
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COLON in state 27 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 27 resolved as shift
WARNING: shift/reduce conflict for COLON in state 28 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 28 resolved as shift
WARNING: shift/reduce conflict for ID in state 28 resolved as shift
WARNING: shift/reduce conflict for DISP in state 28 resolved as shift
WARNING: shift/reduce conflict for PXL_ON in state 28 resolved as shift
WARNING: shift/reduce conflict for IF in state 28 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 28 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 28 resolved as shift
WARNING: shift/reduce conflict for FOR in state 28 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 28 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 28 resolved as shift
WARNING: shift/reduce conflict for SUB in state 28 resolved as shift
WARNING: shift/reduce conflict for DEBUG in state 28 resolved as shift
WARNING: shift/reduce conflict for EXIT in state 28 resolved as shift
WARNING: shift/reduce conflict for VAR in state 28 resolved as shift
WARNING: shift/reduce conflict for LBRACK in state 28 resolved as shift
WARNING: shift/reduce conflict for CONST in state 28 resolved as shift
WARNING: shift/reduce conflict for RAND in state 28 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 33 resolved as shift
WARNING: shift/reduce conflict for ADD in state 33 resolved as shift
WARNING: shift/reduce conflict for SUB in state 33 resolved as shift
WARNING: shift/reduce conflict for MUL in state 33 resolved as shift
WARNING: shift/reduce conflict for DIV in state 33 resolved as shift
WARNING: shift/reduce conflict for MOD in state 33 resolved as shift
WARNING: shift/reduce conflict for LT in state 33 resolved as shift
WARNING: shift/reduce conflict for LE in state 33 resolved as shift
WARNING: shift/reduce conflict for EQ in state 33 resolved as shift
WARNING: shift/reduce conflict for NE in state 33 resolved as shift
WARNING: shift/reduce conflict for GT in state 33 resolved as shift
WARNING: shift/reduce conflict for GE in state 33 resolved as shift
WARNING: shift/reduce conflict for COLON in state 38 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 38 resolved as shift
WARNING: shift/reduce conflict for ID in state 38 resolved as shift
WARNING: shift/reduce conflict for DISP in state 38 resolved as shift
WARNING: shift/reduce conflict for PXL_ON in state 38 resolved as shift
WARNING: shift/reduce conflict for IF in state 38 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 38 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 38 resolved as shift
WARNING: shift/reduce conflict for FOR in state 38 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 38 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 38 resolved as shift
WARNING: shift/reduce conflict for SUB in state 38 resolved as shift
WARNING: shift/reduce conflict for DEBUG in state 38 resolved as shift
WARNING: shift/reduce conflict for EXIT in state 38 resolved as shift
WARNING: shift/reduce conflict for VAR in state 38 resolved as shift
WARNING: shift/reduce conflict for LBRACK in state 38 resolved as shift
WARNING: shift/reduce conflict for CONST in state 38 resolved as shift
WARNING: shift/reduce conflict for RAND in state 38 resolved as shift
WARNING: shift/reduce conflict for COLON in state 39 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 39 resolved as shift
WARNING: shift/reduce conflict for COLON in state 42 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 42 resolved as shift
WARNING: shift/reduce conflict for ID in state 42 resolved as shift
WARNING: shift/reduce conflict for DISP in state 42 resolved as shift
WARNING: shift/reduce conflict for PXL_ON in state 42 resolved as shift
WARNING: shift/reduce conflict for IF in state 42 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 42 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 42 resolved as shift
WARNING: shift/reduce conflict for FOR in state 42 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 42 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 42 resolved as shift
WARNING: shift/reduce conflict for SUB in state 42 resolved as shift
WARNING: shift/reduce conflict for DEBUG in state 42 resolved as shift
WARNING: shift/reduce conflict for EXIT in state 42 resolved as shift
WARNING: shift/reduce conflict for VAR in state 42 resolved as shift
WARNING: shift/reduce conflict for LBRACK in state 42 resolved as shift
WARNING: shift/reduce conflict for CONST in state 42 resolved as shift
WARNING: shift/reduce conflict for RAND in state 42 resolved as shift
WARNING: shift/reduce conflict for COLON in state 43 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 43 resolved as shift
WARNING: shift/reduce conflict for ID in state 43 resolved as shift
WARNING: shift/reduce conflict for DISP in state 43 resolved as shift
WARNING: shift/reduce conflict for PXL_ON in state 43 resolved as shift
WARNING: shift/reduce conflict for IF in state 43 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 43 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 43 resolved as shift
WARNING: shift/reduce conflict for FOR in state 43 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 43 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 43 resolved as shift
WARNING: shift/reduce conflict for SUB in state 43 resolved as shift
WARNING: shift/reduce conflict for DEBUG in state 43 resolved as shift
WARNING: shift/reduce conflict for EXIT in state 43 resolved as shift
WARNING: shift/reduce conflict for VAR in state 43 resolved as shift
WARNING: shift/reduce conflict for LBRACK in state 43 resolved as shift
WARNING: shift/reduce conflict for CONST in state 43 resolved as shift
WARNING: shift/reduce conflict for RAND in state 43 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 44 resolved as shift
WARNING: shift/reduce conflict for COLON in state 49 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 49 resolved as shift
WARNING: shift/reduce conflict for COLON in state 54 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 54 resolved as shift
WARNING: shift/reduce conflict for COLON in state 64 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 64 resolved as shift
WARNING: shift/reduce conflict for ID in state 64 resolved as shift
WARNING: shift/reduce conflict for DISP in state 64 resolved as shift
WARNING: shift/reduce conflict for PXL_ON in state 64 resolved as shift
WARNING: shift/reduce conflict for IF in state 64 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 64 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 64 resolved as shift
WARNING: shift/reduce conflict for FOR in state 64 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 64 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 64 resolved as shift
WARNING: shift/reduce conflict for SUB in state 64 resolved as shift
WARNING: shift/reduce conflict for DEBUG in state 64 resolved as shift
WARNING: shift/reduce conflict for EXIT in state 64 resolved as shift
WARNING: shift/reduce conflict for VAR in state 64 resolved as shift
WARNING: shift/reduce conflict for LBRACK in state 64 resolved as shift
WARNING: shift/reduce conflict for CONST in state 64 resolved as shift
WARNING: shift/reduce conflict for RAND in state 64 resolved as shift
WARNING: shift/reduce conflict for COLON in state 66 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 66 resolved as shift
WARNING: shift/reduce conflict for COLON in state 69 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 69 resolved as shift
WARNING: shift/reduce conflict for COLON in state 75 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 75 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 82 resolved as shift
WARNING: shift/reduce conflict for ADD in state 82 resolved as shift
WARNING: shift/reduce conflict for SUB in state 82 resolved as shift
WARNING: shift/reduce conflict for MUL in state 82 resolved as shift
WARNING: shift/reduce conflict for DIV in state 82 resolved as shift
WARNING: shift/reduce conflict for MOD in state 82 resolved as shift
WARNING: shift/reduce conflict for LT in state 82 resolved as shift
WARNING: shift/reduce conflict for LE in state 82 resolved as shift
WARNING: shift/reduce conflict for EQ in state 82 resolved as shift
WARNING: shift/reduce conflict for NE in state 82 resolved as shift
WARNING: shift/reduce conflict for GT in state 82 resolved as shift
WARNING: shift/reduce conflict for GE in state 82 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 91 resolved as shift
WARNING: shift/reduce conflict for COLON in state 98 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 98 resolved as shift
WARNING: shift/reduce conflict for COLON in state 100 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 100 resolved as shift
WARNING: shift/reduce conflict for COLON in state 103 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 103 resolved as shift
WARNING: shift/reduce conflict for COLON in state 107 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 107 resolved as shift
WARNING: shift/reduce conflict for COLON in state 111 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 111 resolved as shift
WARNING: reduce/reduce conflict in state 6 resolved using rule (expression -> NUMBER)
WARNING: rejected rule (factor -> NUMBER) in state 6
WARNING: reduce/reduce conflict in state 24 resolved using rule (expression -> tempexpression)
WARNING: rejected rule (factor -> tempexpression) in state 24
WARNING: reduce/reduce conflict in state 78 resolved using rule (expression -> tempexpression)
WARNING: rejected rule (factor -> tempexpression) in state 78
WARNING: reduce/reduce conflict in state 79 resolved using rule (factor -> NUMBER)
WARNING: rejected rule (expression -> NUMBER) in state 79
WARNING: Rule (factor -> tempexpression) is never reduced
